#! /usr/bin/env python
# Copyright 2018 Martin C. Frith

import bisect
import gzip
import itertools
import optparse
import os
import signal
import sys

def myOpen(fileName):  # faster than fileinput
    if fileName == "-":
        return sys.stdin
    if fileName.endswith(".gz"):
        return gzip.open(fileName)
    return open(fileName)

def log(opts, s):
    if opts.verbose:
        sys.stderr.write(s + "\n")

def openAndLog(opts, fileName):
    f = myOpen(fileName)
    log(opts, "reading " + fileName + "...")
    return f

def isConsecutive(numbers):
    for i, x in enumerate(numbers):
        if i and x != numbers[i - 1] + 1:
            return False
    return True

def maxRangeLength(ranges):
    return max(i[2] - i[1] for i in ranges) if ranges else 0

def overlappingRanges(queryRange, sortedRanges, maxSortedRangeLength):
    chrom, beg, end = queryRange
    i = bisect.bisect(sortedRanges, queryRange)
    j = i
    while j > 0:
        j -= 1
        chrom0, beg0, end0 = sortedRanges[j][:3]
        if chrom0 < chrom or beg0 + maxSortedRangeLength <= beg:
            break
        if end0 > beg:
            yield j
    while i < len(sortedRanges):
        chrom0, beg0, end0 = sortedRanges[i][:3]
        if chrom0 > chrom or beg0 >= end:
            break
        yield i
        i += 1

def getInts(text):
    for i in text.rstrip(",").split(","):
        yield int(i)

def genePartsFromLines(opts, lines):
    utrs = "5'UTR", "3'UTR"
    parts = ("E" in opts.parts) + 2 * ("I" in opts.parts)
    for line in lines:
        fields = line.split()
        if len(fields) < 6 or fields[5] in "+-":  # BED
            chrom = fields[0]
            chromBeg = int(fields[1])
            chromEnd = int(fields[2])
            geneName = fields[3] if len(fields) > 3 else "."
            if len(fields) < 12:
                yield chrom, chromBeg, chromEnd, geneName, "."
                continue
            strand = fields[5]
            exonBegs = [chromBeg + i for i in getInts(fields[11])]
            exonEnds = [i + j for i, j in zip(exonBegs, getInts(fields[10]))]
        else:  # genePred
            chrom = fields[2]
            strand = fields[3]
            exonBegs = list(getInts(fields[9]))
            exonEnds = list(getInts(fields[10]))
            if len(fields) > 12:
                geneName = fields[12]
            else:
                geneName = fields[0]
        cdsBeg = int(fields[6])
        cdsEnd = int(fields[7])
        if cdsBeg >= cdsEnd:
            begUtr = endUtr = "exon"
        elif strand == "-":
            endUtr, begUtr = utrs
        else:
            begUtr, endUtr = utrs
        oldEnd = 0
        for beg, end in zip(exonBegs, exonEnds):
            if parts > 1 and oldEnd:
                yield chrom, oldEnd, beg, geneName, "intron"
            oldEnd = end
            if parts % 2 == 0:
                continue
            if beg < cdsBeg:
                myEnd = min(end, cdsBeg)
                yield chrom, beg, myEnd, geneName, begUtr
            if end > cdsBeg and beg < cdsEnd:
                myBeg = max(beg, cdsBeg)
                myEnd = min(end, cdsEnd)
                yield chrom, myBeg, myEnd, geneName, "coding"
            if end > cdsEnd:
                myBeg = max(beg, cdsEnd)
                yield chrom, myBeg, end, geneName, endUtr

def geneInfoFromParts(geneParts, partNums):
    parts = [geneParts[i] for i in partNums]
    if not parts:
        return ".", "intergenic"
    types = [i[4] for i in parts]
    for t in ".", "coding", "5'UTR", "3'UTR", "exon", "promoter", "intron":
        if t in types:
            names = ",".join(sorted(set(i[3] for i in parts if i[4] == t)))
            return names, t
    assert False

def tandemRepeatsFromLines(opts, lines, geneParts):
    maxPartLength = maxRangeLength(geneParts)
    for line in lines:
        fields = line.split()
        if len(fields) == 5:  # microsat.txt
            fields.pop(0)
        if len(fields) == 4:
            unit = fields[3]
            if "x" in unit:
                repeatCount, unit = unit.split("x")
            chrom = fields[0]
            beg = int(fields[1])
            end = int(fields[2])
        elif len(fields) == 17 and fields[4] == "trf":  # simpleRepeat.txt
            unit = fields[16]
            if int(fields[5]) != len(unit) or int(fields[7]) != len(unit):
                continue  # weird, maybe hard case: don't try it
            chrom = fields[1]
            beg = int(fields[2])
            end = int(fields[3])
        elif len(fields) == 17 and fields[11] == "Simple_repeat":  # rmsk.txt
            unit = fields[10][1:-2]
            chrom = fields[5]
            beg = int(fields[6])
            end = int(fields[7])
        elif len(fields) == 15 and fields[10] == "Simple_repeat":  # RMSK .out
            unit = fields[9][1:-2]
            chrom = fields[4]
            beg = int(fields[5]) - 1
            end = int(fields[6])
        else:
            continue
        if len(unit) < opts.min_unit:
            continue
        if opts.min_unit > 1 and len(set(unit)) == 1:  # idiot-proofing
            continue
        if geneParts is None:
            geneInfo = ".", "."
        else:
            r = chrom, beg, end
            partNums = overlappingRanges(r, geneParts, maxPartLength)
            geneInfo = geneInfoFromParts(geneParts, partNums)
            if geneInfo[1] == "intergenic":
                continue
        yield chrom, beg, end, unit, geneInfo, []

def alignmentsFromMaf(lines):
    alignment = []
    for line in lines:
        if line[0] == "s":
            fields = line.split()
            seqName = fields[1]
            beg = int(fields[2])
            strand = fields[4]
            seqLen = int(fields[5])
            alignedSeq = fields[6]
            end = beg + len(alignedSeq) - alignedSeq.count("-")
            seqData = seqName, seqLen, strand, beg, end, alignedSeq
            alignment.append(seqData)
        elif line.isspace():
            if alignment:
                yield alignment
                alignment = []
    if alignment:
        yield alignment

def refSeqName(alignment):
    return alignment[0][0]

def refSeqLen(alignment):
    return alignment[0][1]

def refSeqBeg(alignment):
    return alignment[0][3]

def refSeqEnd(alignment):
    return alignment[0][4]

def qrySeqName(alignment):
    return alignment[1][0]

def qrySeqBeg(alignment):
    return alignment[1][3]

def qrySeqEnd(alignment):
    return alignment[1][4]

def isFwdColinear(oldAln, newAln):
    """Is oldAln upstream of newAln in all sequences?"""
    return all(i[4] <= j[3] for i, j in zip(oldAln, newAln))

def isFwd(colinearAlignments):
    return isFwdColinear(colinearAlignments[0], colinearAlignments[1])

def isColinear(colinearAlignments, newAln):
    oldAln = colinearAlignments[-1]
    if any(i[:3] != j[:3] for i, j in zip(oldAln, newAln)):
        return False
    if len(colinearAlignments) == 1:
        return isFwdColinear(oldAln, newAln) or isFwdColinear(newAln, oldAln)
    if isFwd(colinearAlignments):
        return isFwdColinear(oldAln, newAln)
    else:
        return isFwdColinear(newAln, oldAln)

def canonicalize(colinearAlignments):
    if len(colinearAlignments) > 1 and not isFwd(colinearAlignments):
        colinearAlignments.reverse()

def colinearAlignmentGroups(alignments):
    colinearAlignments = []
    for i in alignments:
        if colinearAlignments and not isColinear(colinearAlignments, i):
            canonicalize(colinearAlignments)
            yield colinearAlignments
            colinearAlignments = []
        colinearAlignments.append(i)
    if colinearAlignments:
        canonicalize(colinearAlignments)
        yield colinearAlignments

def gapsFromColinearAlignments(alignments):
    refSeqPos = refSeqBeg(alignments[0])
    insSize = delSize = 0
    isInterAlignment = False
    for j, b in enumerate(alignments):
        if j:
            a = alignments[j - 1]
            delSize += refSeqBeg(b) - refSeqEnd(a)
            insSize += qrySeqBeg(b) - qrySeqEnd(a)
            isInterAlignment = True
        alignmentColumns = itertools.izip(b[0][5], b[1][5])
        # use "read-ahead" technique, aiming to be as fast as possible:
        for x, y in alignmentColumns: break
        while True:
            if x == "-":
                insSize += 1
                for x, y in alignmentColumns:
                    if x != "-": break
                    insSize += 1
                else: break
            elif y == "-":
                delSize += 1
                for x, y in alignmentColumns:
                    if y != "-": break
                    delSize += 1
                else: break
            else:
                if insSize or delSize:
                    yield (refSeqPos, refSeqPos + delSize, insSize - delSize,
                           isInterAlignment)
                    refSeqPos += delSize
                    insSize = delSize = 0
                    isInterAlignment = False
                refSeqPos += 1
                for x, y in alignmentColumns:
                    if x == "-" or y == "-": break
                    refSeqPos += 1
                else: break

def numberOfPeriods(gapLength, repeatPeriod):  # crude
    if gapLength < 0:
        return -numberOfPeriods(-gapLength, repeatPeriod)
    return (gapLength + (repeatPeriod - 1) // 2) // repeatPeriod

def doAppend(copyNumberChanges, change, queryName):
    t = change, queryName
    copyNumberChanges.append(t)

def appendCopyNumberChange(opts, tandemRepeat, gaps, queryName):
    """Estimate copy number change from alignment gaps: crude and ad hoc"""
    chrom, repBeg, repEnd, unit, geneInfo, copyNumberChanges = tandemRepeat
    repLen = repEnd - repBeg
    minAlignedFlank = (repLen + 1) // 2
    maxAlnBeg = repBeg - minAlignedFlank
    minAlnEnd = repEnd + minAlignedFlank
    period = len(unit)
    diff = 0
    for gapBeg, gapEnd, gapLen, isInterAlignment in gaps:
        if gapEnd <= maxAlnBeg or gapBeg >= minAlnEnd:
            continue
        if (gapEnd <= repBeg or gapBeg >= repEnd) and gapLen <= 0:
            continue  # ignore deletions adjacent to the repeat
        if opts.mode == "S":
            if isInterAlignment and gapLen > 0:
                return  # suspicious, unexpected insertion: give up
            if gapEnd < repBeg or gapBeg > repEnd:
                continue
            if gapBeg <= repBeg and gapEnd >= repEnd:
                return  # no alignment to the repeat: give up
        if gapBeg <= maxAlnBeg or gapEnd >= minAlnEnd:
            return  # a gap goes too far beyond the repeat: give up
        overlap = min(gapEnd, repEnd) - max(gapBeg, repBeg)
        overlap = max(overlap, 0)
        myLen = max(gapLen, -overlap)  # don't count deletion beyond the repeat
        diff += numberOfPeriods(myLen, period)
    doAppend(copyNumberChanges, diff, queryName)

def joinedAlnNumsPerRepeat(repNumsPerJoinedAln, repNum):
    for i, x in enumerate(repNumsPerJoinedAln):
        if repNum in x:
            yield i

def alignedStrand(joinedAln):
    return joinedAln[0][1][2]

def doOneRepeat(opts, joinedAlns, gaps, rep, joinedAlnNums):
    if not isConsecutive(joinedAlnNums):
        return
    myJoinedAlns = [joinedAlns[i] for i in joinedAlnNums]
    strand = alignedStrand(myJoinedAlns[0])
    if any(alignedStrand(i) != strand for i in myJoinedAlns):
        return
    if strand == "-":
        myJoinedAlns.reverse()
    joinedAlnA = myJoinedAlns[0]
    joinedAlnZ = myJoinedAlns[-1]
    alnBegA = refSeqBeg(joinedAlnA[0])
    alnEndZ = refSeqEnd(joinedAlnZ[-1])
    repBeg = rep[1]
    repEnd = rep[2]
    repLen = repEnd - repBeg
    minAlignedFlank = (repLen + 1) // 2  # xxx ???
    refLen = refSeqLen(joinedAlnA[0])
    maxAlnBeg = max(repBeg - minAlignedFlank, 0)
    minAlnEnd = min(repEnd + minAlignedFlank, refLen)
    if alnBegA > maxAlnBeg or alnEndZ < minAlnEnd:
        return
    queryName = qrySeqName(joinedAlnA[0])
    if len(myJoinedAlns) == 1:
        appendCopyNumberChange(opts, rep, gaps[joinedAlnNums[0]], queryName)
    else:
        tooFar = repLen * 3  # xxx ???
        badBeg = max(alnBegA, repBeg - tooFar)
        badEnd = min(alnEndZ, repEnd + tooFar)
        for i in myJoinedAlns[1:]:
            b = refSeqBeg(i[0])
            if b <= badBeg or alnBegA > max(b - minAlignedFlank, 0):
                return
        for i in myJoinedAlns[:-1]:
            e = refSeqEnd(i[-1])
            if e >= badEnd or alnEndZ < min(e + minAlignedFlank, refLen):
                return
        tailAlnA = joinedAlnA[-1]
        headAlnZ = joinedAlnZ[0]
        insertionSize = (qrySeqBeg(headAlnZ) - qrySeqEnd(tailAlnA) +
                         refSeqEnd(tailAlnA) - refSeqBeg(headAlnZ))
        change = numberOfPeriods(insertionSize, len(rep[3]))
        doAppend(rep[5], change, queryName)

def repeatNumsPerJoinedAln(tandemRepeats, maxRepeatLength, joinedAlns):
    for joinedAln in joinedAlns:
        headAln = joinedAln[0]
        tailAln = joinedAln[-1]
        r = refSeqName(headAln), refSeqBeg(headAln), refSeqEnd(tailAln)
        yield set(overlappingRanges(r, tandemRepeats, maxRepeatLength))

def gapsPerJoinedAln(joinedAlns, isNeeded):
    for i, j in zip(joinedAlns, isNeeded):
        yield list(gapsFromColinearAlignments(i)) if j else None

def doOneQuerySequence(opts, tandemRepeats, maxRepeatLength, alignments):
    joinedAlns = list(colinearAlignmentGroups(alignments))
    g = repeatNumsPerJoinedAln(tandemRepeats, maxRepeatLength, joinedAlns)
    repNumsPerJoinedAln = list(g)
    gaps = list(gapsPerJoinedAln(joinedAlns, repNumsPerJoinedAln))
    repNums = set(itertools.chain.from_iterable(repNumsPerJoinedAln))
    for i in repNums:
        rep = tandemRepeats[i]
        joinedAlnNums = list(joinedAlnNumsPerRepeat(repNumsPerJoinedAln, i))
        doOneRepeat(opts, joinedAlns, gaps, rep, joinedAlnNums)

def doOneMafFile(opts, tandemRepeats, maxRepeatLength, lines):
    alignments = alignmentsFromMaf(lines)
    for k, v in itertools.groupby(alignments, qrySeqName):
        doOneQuerySequence(opts, tandemRepeats, maxRepeatLength, v)

def tandemGenotypes(opts, args):
    geneParts = None
    if opts.genes:
        geneFile = openAndLog(opts, opts.genes)
        geneParts = sorted(genePartsFromLines(opts, geneFile))

    repFile = openAndLog(opts, args[0])
    tandemRepeats = sorted(tandemRepeatsFromLines(opts, repFile, geneParts))
    maxRepeatLength = maxRangeLength(tandemRepeats)

    fileNames = args[1:] if len(args) > 1 else ["-"]
    for i in fileNames:
        doOneMafFile(opts, tandemRepeats, maxRepeatLength, openAndLog(opts, i))

    prog = os.path.basename(sys.argv[0])
    print "#", prog, " ".join(sys.argv[1:])

    for chrom, beg, end, unit, geneInfo, copyNumberChanges in tandemRepeats:
        if copyNumberChanges and any(i[0] for i in copyNumberChanges):
            s = sorted(copyNumberChanges)
            if opts.verbose:
                changes = " ".join(str(i[0]) + ":" + i[1] for i in s)
            else:
                changes = " ".join("%3d" % i[0] for i in s)
            out = chrom, str(beg), str(end), unit, "\t".join(geneInfo), changes
            print "\t".join(out)

if __name__ == "__main__":
    signal.signal(signal.SIGPIPE, signal.SIG_DFL)  # avoid silly error message
    usage = "%prog [options] microsat.txt alignments.maf"
    description = "Try to indicate genotypes of tandem repeats."
    op = optparse.OptionParser(usage=usage, description=description)
    op.add_option("-g", "--genes", metavar="FILE", help=
                  "only check tandem repeats that overlap genes "
                  "in a genePred or BED file")
    op.add_option("-p", "--parts", metavar="LETTERS", default="E", help=
                  "only check tandem repeats that overlap these gene parts: "
                  "E=exons, I=introns (default=%default)")
    op.add_option("-u", "--min-unit", type="int", default=2, metavar="BP",
                  help="ignore repeats with unit shorter than BP "
                  "(default=%default)")
    op.add_option("--mode", default="S", metavar="LETTER",
                  help="S=strict, L=lenient (default=%default)")
    op.add_option("-v", "--verbose", action="count", help="show more details")
    opts, args = op.parse_args()
    if not args:
        op.error("please give me repeats and MAF alignments")
    tandemGenotypes(opts, args)
