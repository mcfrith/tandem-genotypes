#! /usr/bin/env python
# Copyright 2018 Martin C. Frith

import bisect
import gzip
import itertools
import optparse
import signal
import sys

def myOpen(fileName):  # faster than fileinput
    if fileName == "-":
        return sys.stdin
    if fileName.endswith(".gz"):
        return gzip.open(fileName)
    return open(fileName)

def maxRangeLength(ranges):
    return max(i[2] - i[1] for i in ranges) if ranges else 0

def overlappingRanges(queryRange, sortedRanges, maxSortedRangeLength):
    chrom, beg, end = queryRange
    i = bisect.bisect(sortedRanges, queryRange)
    j = i
    while j > 0:
        j -= 1
        chrom0, beg0, end0 = sortedRanges[j][:3]
        if chrom0 < chrom or beg0 + maxSortedRangeLength <= beg:
            break
        if end0 > beg:
            yield j
    while i < len(sortedRanges):
        chrom0, beg0, end0 = sortedRanges[i][:3]
        if chrom0 > chrom or beg0 >= end:
            break
        yield i
        i += 1

def exonsFromLines(lines):
    for line in lines:
        fields = line.split()
        chrom = fields[2]
        exonBegs = fields[9].rstrip(",").split(",")
        exonEnds = fields[10].rstrip(",").split(",")
        if len(fields) > 12:
            geneName = fields[12]
        else:
            geneName = fields[0]
        for beg, end in zip(exonBegs, exonEnds):
            yield chrom, int(beg), int(end), geneName

def tandemRepeatsFromLines(lines, sortedExons):
    maxExonLength = maxRangeLength(sortedExons)
    for line in lines:
        fields = line.split()
        if len(fields) == 5:  # microsat.txt
            repeatCount, unit = fields[4].split("x")
            chrom = fields[1]
            beg = int(fields[2])
            end = int(fields[3])
        elif len(fields) == 17 and fields[4] == "trf":  # simpleRepeat.txt
            unit = fields[16]
            if int(fields[5]) != len(unit) or int(fields[7]) != len(unit):
                continue  # weird, maybe hard case: don't try it
            chrom = fields[1]
            beg = int(fields[2])
            end = int(fields[3])
        elif len(fields) == 17 and fields[11] == "Simple_repeat":  # rmsk.txt
            unit = fields[10][1:-2]
            chrom = fields[5]
            beg = int(fields[6])
            end = int(fields[7])
        elif len(fields) == 15 and fields[10] == "Simple_repeat":  # RMSK .out
            unit = fields[9][1:-2]
            chrom = fields[4]
            beg = int(fields[5]) - 1
            end = int(fields[6])
        else:
            continue
        if len(set(unit)) == 1:
            continue  # don't try homo-polymers
        if sortedExons is None:
            geneNames = ["."]
        else:
            r = chrom, beg, end
            exonNums = overlappingRanges(r, sortedExons, maxExonLength)
            geneNames = sorted(set(sortedExons[i][3] for i in exonNums))
            if not geneNames:
                continue
        yield chrom, beg, end, unit, geneNames, []

def containedRanges(queryRanges, containingRange):
    chrom, beg, end = containingRange
    i = bisect.bisect(queryRanges, containingRange)
    while i < len(queryRanges):
        r = queryRanges[i]
        chrom0, beg0, end0 = r[:3]
        if chrom0 > chrom or beg0 >= end:
            break
        if beg0 > beg and end0 < end:
            yield r
        i += 1

def alignmentsFromMaf(lines):
    alignment = []
    for line in lines:
        if line[0] == "s":
            fields = line.split()
            seqName = fields[1]
            beg = int(fields[2])
            strand = fields[4]
            alignedSeq = fields[6]
            end = beg + len(alignedSeq) - alignedSeq.count("-")
            seqData = seqName, strand, beg, end, alignedSeq
            alignment.append(seqData)
        elif line.isspace():
            if alignment:
                yield alignment
                alignment = []
    if alignment:
        yield alignment

def isFwdColinear(oldAln, newAln):
    """Is oldAln upstream of newAln in all sequences?"""
    return all(i[3] <= j[2] for i, j in zip(oldAln, newAln))

def isColinear(colinearAlignments, newAln):
    oldAln = colinearAlignments[-1]
    if any(i[:2] != j[:2] for i, j in zip(oldAln, newAln)):
        return False
    if len(colinearAlignments) == 1:
        return isFwdColinear(oldAln, newAln) or isFwdColinear(newAln, oldAln)
    if isFwdColinear(colinearAlignments[0], colinearAlignments[1]):
        return isFwdColinear(oldAln, newAln)
    else:
        return isFwdColinear(newAln, oldAln)

def colinearAlignmentGroups(alignments):
    colinearAlignments = []
    for i in alignments:
        if colinearAlignments and not isColinear(colinearAlignments, i):
            yield colinearAlignments
            colinearAlignments = []
        colinearAlignments.append(i)
    if colinearAlignments:
        yield colinearAlignments

def gapsFromColinearAlignments(alignments):
    topSeqPos = alignments[0][0][2]
    insSize = delSize = 0
    for j, b in enumerate(alignments):
        if j:
            a = alignments[j - 1]
            delSize += b[0][2] - a[0][3]
            insSize += b[1][2] - a[1][3]
        alignmentColumns = itertools.izip(b[0][4], b[1][4])
        # use "read-ahead" technique, aiming to be as fast as possible:
        for x, y in alignmentColumns: break
        while True:
            if x == "-":
                insSize += 1
                for x, y in alignmentColumns:
                    if x != "-": break
                    insSize += 1
                else: break
            elif y == "-":
                delSize += 1
                for x, y in alignmentColumns:
                    if y != "-": break
                    delSize += 1
                else: break
            else:
                if insSize or delSize:
                    yield topSeqPos, topSeqPos + delSize, insSize - delSize
                    topSeqPos += delSize
                    insSize = delSize = 0
                topSeqPos += 1
                for x, y in alignmentColumns:
                    if x == "-" or y == "-": break
                    topSeqPos += 1
                else: break

def numberOfPeriods(gapLength, repeatPeriod):  # crude
    if gapLength < 0:
        return -numberOfPeriods(-gapLength, repeatPeriod)
    return (gapLength + (repeatPeriod - 1) // 2) // repeatPeriod

def appendCopyNumberChange(tandemRepeat, gaps):
    chrom, beg, end, unit, geneNames, copyNumberChanges = tandemRepeat
    period = len(unit)
    diff = 0
    for gapBeg, gapEnd, gapLen in gaps:
        if gapBeg < beg and gapEnd > beg:
            return  # a deletion goes beyond the repeat: give up
        if gapBeg < end and gapEnd > end:
            return  # a deletion goes beyond the repeat: give up
        if gapBeg >= beg and gapEnd <= end:
            diff += numberOfPeriods(gapLen, period)
    copyNumberChanges.append(diff)

def doColinearAlignments(tandemRepeats, alignments):
    if len(alignments) > 1 and isFwdColinear(alignments[1], alignments[0]):
        alignments.reverse()
    head = alignments[0]
    tail = alignments[-1]
    alignmentRange = head[0][0], head[0][2], tail[0][3]
    reps = list(containedRanges(tandemRepeats, alignmentRange))
    if reps:
        gaps = list(gapsFromColinearAlignments(alignments))
        for i in reps:
            appendCopyNumberChange(i, gaps)

def doOneMafFile(tandemRepeats, lines):
    for i in colinearAlignmentGroups(alignmentsFromMaf(lines)):
        doColinearAlignments(tandemRepeats, i)

def tandemGenotypes(opts, args):
    exons = sorted(exonsFromLines(myOpen(opts.genes))) if opts.genes else None
    tandemRepeats = sorted(tandemRepeatsFromLines(myOpen(args[0]), exons))

    if len(args) > 1:
        for fileName in args[1:]:
            doOneMafFile(tandemRepeats, myOpen(fileName))
    else:
        doOneMafFile(tandemRepeats, sys.stdin)

    for chrom, beg, end, unit, geneNames, copyNumberChanges in tandemRepeats:
        if copyNumberChanges and any(i != 0 for i in copyNumberChanges):
            changes = " ".join("%3d" % i for i in sorted(copyNumberChanges))
            out = chrom, str(beg), str(end), unit, ",".join(geneNames), changes
            print "\t".join(out)

if __name__ == "__main__":
    signal.signal(signal.SIGPIPE, signal.SIG_DFL)  # avoid silly error message
    usage = "%prog [options] microsat.txt alignments.maf"
    description = "Try to indicate genotypes of tandem repeats."
    op = optparse.OptionParser(usage=usage, description=description)
    op.add_option("-g", "--genes", metavar="FILE", help=
                  "only check tandem repeats that overlap exons of genes "
                  "in a genePred file")
    opts, args = op.parse_args()
    if not args:
        op.error("please give me repeats and MAF alignments")
    tandemGenotypes(opts, args)
