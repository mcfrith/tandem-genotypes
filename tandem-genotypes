#! /usr/bin/env python
# Copyright 2018 Martin C. Frith

import bisect
import gzip
import itertools
import optparse
import os
import signal
import sys

def myOpen(fileName):  # faster than fileinput
    if fileName == "-":
        return sys.stdin
    if fileName.endswith(".gz"):
        return gzip.open(fileName)
    return open(fileName)

def log(opts, s):
    if opts.verbose:
        sys.stderr.write(s + "\n")

def openAndLog(opts, fileName):
    f = myOpen(fileName)
    log(opts, "reading " + fileName + "...")
    return f

def isConsecutive(numbers):
    for i, x in enumerate(numbers):
        if i and x != numbers[i - 1] + 1:
            return False
    return True

def maxRangeLength(ranges):
    return max(i[2] - i[1] for i in ranges) if ranges else 0

def overlappingRanges(queryRange, sortedRanges, maxSortedRangeLength):
    chrom, beg, end = queryRange
    i = bisect.bisect(sortedRanges, queryRange)
    j = i
    while j > 0:
        j -= 1
        chrom0, beg0, end0 = sortedRanges[j][:3]
        if chrom0 < chrom or beg0 + maxSortedRangeLength <= beg:
            break
        if end0 > beg:
            yield j
    while i < len(sortedRanges):
        chrom0, beg0, end0 = sortedRanges[i][:3]
        if chrom0 > chrom or beg0 >= end:
            break
        yield i
        i += 1

def exonsFromLines(lines):
    for line in lines:
        fields = line.split()
        chrom = fields[2]
        exonBegs = fields[9].rstrip(",").split(",")
        exonEnds = fields[10].rstrip(",").split(",")
        if len(fields) > 12:
            geneName = fields[12]
        else:
            geneName = fields[0]
        for beg, end in zip(exonBegs, exonEnds):
            yield chrom, int(beg), int(end), geneName

def tandemRepeatsFromLines(lines, sortedExons):
    maxExonLength = maxRangeLength(sortedExons)
    for line in lines:
        fields = line.split()
        if len(fields) == 5:  # microsat.txt
            fields.pop(0)
        if len(fields) == 4:
            unit = fields[3]
            if "x" in unit:
                repeatCount, unit = unit.split("x")
            chrom = fields[0]
            beg = int(fields[1])
            end = int(fields[2])
        elif len(fields) == 17 and fields[4] == "trf":  # simpleRepeat.txt
            unit = fields[16]
            if int(fields[5]) != len(unit) or int(fields[7]) != len(unit):
                continue  # weird, maybe hard case: don't try it
            chrom = fields[1]
            beg = int(fields[2])
            end = int(fields[3])
        elif len(fields) == 17 and fields[11] == "Simple_repeat":  # rmsk.txt
            unit = fields[10][1:-2]
            chrom = fields[5]
            beg = int(fields[6])
            end = int(fields[7])
        elif len(fields) == 15 and fields[10] == "Simple_repeat":  # RMSK .out
            unit = fields[9][1:-2]
            chrom = fields[4]
            beg = int(fields[5]) - 1
            end = int(fields[6])
        else:
            continue
        if len(set(unit)) == 1:
            continue  # don't try homo-polymers
        if sortedExons is None:
            geneNames = ["."]
        else:
            r = chrom, beg, end
            exonNums = overlappingRanges(r, sortedExons, maxExonLength)
            geneNames = sorted(set(sortedExons[i][3] for i in exonNums))
            if not geneNames:
                continue
        yield chrom, beg, end, unit, geneNames, []

def alignmentsFromMaf(lines):
    alignment = []
    for line in lines:
        if line[0] == "s":
            fields = line.split()
            seqName = fields[1]
            beg = int(fields[2])
            strand = fields[4]
            alignedSeq = fields[6]
            end = beg + len(alignedSeq) - alignedSeq.count("-")
            seqData = seqName, strand, beg, end, alignedSeq
            alignment.append(seqData)
        elif line.isspace():
            if alignment:
                yield alignment
                alignment = []
    if alignment:
        yield alignment

def refSeqName(alignment):
    return alignment[0][0]

def refSeqBeg(alignment):
    return alignment[0][2]

def refSeqEnd(alignment):
    return alignment[0][3]

def qrySeqName(alignment):
    return alignment[1][0]

def qrySeqBeg(alignment):
    return alignment[1][2]

def qrySeqEnd(alignment):
    return alignment[1][3]

def isFwdColinear(oldAln, newAln):
    """Is oldAln upstream of newAln in all sequences?"""
    return all(i[3] <= j[2] for i, j in zip(oldAln, newAln))

def isFwd(colinearAlignments):
    return isFwdColinear(colinearAlignments[0], colinearAlignments[1])

def isColinear(colinearAlignments, newAln):
    oldAln = colinearAlignments[-1]
    if any(i[:2] != j[:2] for i, j in zip(oldAln, newAln)):
        return False
    if len(colinearAlignments) == 1:
        return isFwdColinear(oldAln, newAln) or isFwdColinear(newAln, oldAln)
    if isFwd(colinearAlignments):
        return isFwdColinear(oldAln, newAln)
    else:
        return isFwdColinear(newAln, oldAln)

def canonicalize(colinearAlignments):
    if len(colinearAlignments) > 1 and not isFwd(colinearAlignments):
        colinearAlignments.reverse()

def colinearAlignmentGroups(alignments):
    colinearAlignments = []
    for i in alignments:
        if colinearAlignments and not isColinear(colinearAlignments, i):
            canonicalize(colinearAlignments)
            yield colinearAlignments
            colinearAlignments = []
        colinearAlignments.append(i)
    if colinearAlignments:
        canonicalize(colinearAlignments)
        yield colinearAlignments

def gapsFromColinearAlignments(alignments):
    refSeqPos = refSeqBeg(alignments[0])
    insSize = delSize = 0
    isInterAlignment = False
    for j, b in enumerate(alignments):
        if j:
            a = alignments[j - 1]
            delSize += refSeqBeg(b) - refSeqEnd(a)
            insSize += qrySeqBeg(b) - qrySeqEnd(a)
            isInterAlignment = True
        alignmentColumns = itertools.izip(b[0][4], b[1][4])
        # use "read-ahead" technique, aiming to be as fast as possible:
        for x, y in alignmentColumns: break
        while True:
            if x == "-":
                insSize += 1
                for x, y in alignmentColumns:
                    if x != "-": break
                    insSize += 1
                else: break
            elif y == "-":
                delSize += 1
                for x, y in alignmentColumns:
                    if y != "-": break
                    delSize += 1
                else: break
            else:
                if insSize or delSize:
                    yield (refSeqPos, refSeqPos + delSize, insSize - delSize,
                           isInterAlignment)
                    refSeqPos += delSize
                    insSize = delSize = 0
                    isInterAlignment = False
                refSeqPos += 1
                for x, y in alignmentColumns:
                    if x == "-" or y == "-": break
                    refSeqPos += 1
                else: break

def numberOfPeriods(gapLength, repeatPeriod):  # crude
    if gapLength < 0:
        return -numberOfPeriods(-gapLength, repeatPeriod)
    return (gapLength + (repeatPeriod - 1) // 2) // repeatPeriod

def doAppend(copyNumberChanges, change, queryName):
    t = change, queryName
    copyNumberChanges.append(t)

def appendCopyNumberChange(tandemRepeat, gaps, queryName):
    """Estimate copy number change from alignment gaps: crude and ad hoc"""
    chrom, repBeg, repEnd, unit, geneNames, copyNumberChanges = tandemRepeat
    repLen = repEnd - repBeg
    minAlignedFlank = (repLen + 1) // 2
    maxAlnBeg = repBeg - minAlignedFlank
    minAlnEnd = repEnd + minAlignedFlank
    period = len(unit)
    diff = 0
    for gapBeg, gapEnd, gapLen, isInterAlignment in gaps:
        if gapEnd < repBeg or gapBeg > repEnd:
            continue
        if gapBeg <= repBeg and gapEnd >= repEnd:
            return  # no alignment to the repeat: give up
        if (gapEnd == repBeg or gapBeg == repEnd) and gapLen <= 0:
            continue  # ignore deletions adjacent to the repeat
        if isInterAlignment and gapLen > 0:
            return  # unexpected colinearity: give up
        if gapBeg <= maxAlnBeg or gapEnd >= minAlnEnd:
            return  # a gap goes too far beyond the repeat: give up
        overlap = min(gapEnd, repEnd) - max(gapBeg, repBeg)
        myLen = max(gapLen, -overlap)  # don't count deletion beyond the repeat
        diff += numberOfPeriods(myLen, period)
    doAppend(copyNumberChanges, diff, queryName)

def joinedAlnNumsPerRepeat(repNumsPerJoinedAln, repNum):
    for i, x in enumerate(repNumsPerJoinedAln):
        if repNum in x:
            yield i

def alignedStrand(joinedAln):
    return joinedAln[0][1][1]

def doOneRepeat(tandemRepeats, joinedAlns, gaps, repNumsPerJoinedAln, repNum):
    joinedAlnNums = list(joinedAlnNumsPerRepeat(repNumsPerJoinedAln, repNum))
    if not isConsecutive(joinedAlnNums):
        return
    myJoinedAlns = [joinedAlns[i] for i in joinedAlnNums]
    strand = alignedStrand(myJoinedAlns[0])
    if any(alignedStrand(i) != strand for i in myJoinedAlns):
        return
    if strand == "-":
        myJoinedAlns.reverse()
    joinedAlnA = myJoinedAlns[0]
    joinedAlnZ = myJoinedAlns[-1]
    alnBegA = refSeqBeg(joinedAlnA[0])
    alnEndZ = refSeqEnd(joinedAlnZ[-1])
    rep = tandemRepeats[repNum]
    repBeg = rep[1]
    repEnd = rep[2]
    repLen = repEnd - repBeg
    minAlignedFlank = (repLen + 1) // 2  # xxx ???
    maxAlnBeg = repBeg - minAlignedFlank
    minAlnEnd = repEnd + minAlignedFlank
    if alnBegA > maxAlnBeg or alnEndZ < minAlnEnd:
        return
    queryName = qrySeqName(joinedAlnA[0])
    if len(myJoinedAlns) == 1:
        appendCopyNumberChange(rep, gaps[joinedAlnNums[0]], queryName)
    else:
        if any(refSeqBeg(i[0]) <= maxAlnBeg for i in myJoinedAlns[1:]):
            return
        if any(refSeqEnd(i[-1]) >= minAlnEnd for i in myJoinedAlns[:-1]):
            return
        tailAlnA = joinedAlnA[-1]
        headAlnZ = joinedAlnZ[0]
        insertionSize = (qrySeqBeg(headAlnZ) - qrySeqEnd(tailAlnA) +
                         refSeqEnd(tailAlnA) - refSeqBeg(headAlnZ))
        change = numberOfPeriods(insertionSize, len(rep[3]))
        doAppend(rep[5], change, queryName)

def repeatNumsPerJoinedAln(tandemRepeats, maxRepeatLength, joinedAlns):
    for joinedAln in joinedAlns:
        headAln = joinedAln[0]
        tailAln = joinedAln[-1]
        r = refSeqName(headAln), refSeqBeg(headAln), refSeqEnd(tailAln)
        yield set(overlappingRanges(r, tandemRepeats, maxRepeatLength))

def gapsPerJoinedAln(joinedAlns, isNeeded):
    for i, j in zip(joinedAlns, isNeeded):
        yield list(gapsFromColinearAlignments(i)) if j else None

def doOneQuerySequence(tandemRepeats, maxRepeatLength, alignments):
    joinedAlns = list(colinearAlignmentGroups(alignments))
    g = repeatNumsPerJoinedAln(tandemRepeats, maxRepeatLength, joinedAlns)
    repNumsPerJoinedAln = list(g)
    gaps = list(gapsPerJoinedAln(joinedAlns, repNumsPerJoinedAln))
    repNums = set(itertools.chain.from_iterable(repNumsPerJoinedAln))
    for i in repNums:
        doOneRepeat(tandemRepeats, joinedAlns, gaps, repNumsPerJoinedAln, i)

def doOneMafFile(tandemRepeats, maxRepeatLength, lines):
    alignments = alignmentsFromMaf(lines)
    for k, v in itertools.groupby(alignments, qrySeqName):
        doOneQuerySequence(tandemRepeats, maxRepeatLength, v)

def tandemGenotypes(opts, args):
    exons = None
    if opts.genes:
        exons = sorted(exonsFromLines(openAndLog(opts, opts.genes)))

    tandemRepeats = sorted(tandemRepeatsFromLines(openAndLog(opts, args[0]),
                                                  exons))
    maxRepeatLength = maxRangeLength(tandemRepeats)

    fileNames = args[1:] if len(args) > 1 else ["-"]
    for i in fileNames:
        doOneMafFile(tandemRepeats, maxRepeatLength, openAndLog(opts, i))

    prog = os.path.basename(sys.argv[0])
    print "#", prog, " ".join(sys.argv[1:])

    for chrom, beg, end, unit, geneNames, copyNumberChanges in tandemRepeats:
        if copyNumberChanges and any(i[0] for i in copyNumberChanges):
            s = sorted(copyNumberChanges)
            if opts.verbose:
                changes = " ".join(str(i[0]) + ":" + i[1] for i in s)
            else:
                changes = " ".join("%3d" % i[0] for i in s)
            out = chrom, str(beg), str(end), unit, ",".join(geneNames), changes
            print "\t".join(out)

if __name__ == "__main__":
    signal.signal(signal.SIGPIPE, signal.SIG_DFL)  # avoid silly error message
    usage = "%prog [options] microsat.txt alignments.maf"
    description = "Try to indicate genotypes of tandem repeats."
    op = optparse.OptionParser(usage=usage, description=description)
    op.add_option("-g", "--genes", metavar="FILE", help=
                  "only check tandem repeats that overlap exons of genes "
                  "in a genePred file")
    op.add_option("-v", "--verbose", action="count", help="show more details")
    opts, args = op.parse_args()
    if not args:
        op.error("please give me repeats and MAF alignments")
    tandemGenotypes(opts, args)
