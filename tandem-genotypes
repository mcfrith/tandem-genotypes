#! /usr/bin/env python
# Copyright 2018 Martin C. Frith

import bisect
import gzip
import itertools
import optparse
import signal
import sys

def myOpen(fileName):  # faster than fileinput
    if fileName == "-":
        return sys.stdin
    if fileName.endswith(".gz"):
        return gzip.open(fileName)
    return open(fileName)

def maxRangeLength(ranges):
    return max(i[2] - i[1] for i in ranges) if ranges else 0

def overlappingRanges(queryRange, sortedRanges, maxSortedRangeLength):
    chrom, beg, end = queryRange
    i = bisect.bisect(sortedRanges, queryRange)
    j = i
    while j > 0:
        j -= 1
        chrom0, beg0, end0 = sortedRanges[j][:3]
        if chrom0 < chrom or beg0 + maxSortedRangeLength <= beg:
            break
        if end0 > beg:
            yield j
    while i < len(sortedRanges):
        chrom0, beg0, end0 = sortedRanges[i][:3]
        if chrom0 > chrom or beg0 >= end:
            break
        yield i
        i += 1

def exonsFromLines(lines):
    for line in lines:
        fields = line.split()
        chrom = fields[2]
        exonBegs = fields[9].rstrip(",").split(",")
        exonEnds = fields[10].rstrip(",").split(",")
        if len(fields) > 12:
            geneName = fields[12]
        else:
            geneName = fields[0]
        for beg, end in zip(exonBegs, exonEnds):
            yield chrom, int(beg), int(end), geneName

def tandemRepeatsFromLines(lines, sortedExons):
    maxExonLength = maxRangeLength(sortedExons)
    for line in lines:
        fields = line.split()
        if len(fields) == 5:  # microsat.txt
            repeatCount, unit = fields[4].split("x")
            chrom = fields[1]
            beg = int(fields[2])
            end = int(fields[3])
        elif len(fields) == 17 and fields[4] == "trf":  # simpleRepeat.txt
            unit = fields[16]
            if int(fields[5]) != len(unit) or int(fields[7]) != len(unit):
                continue  # weird, maybe hard case: don't try it
            chrom = fields[1]
            beg = int(fields[2])
            end = int(fields[3])
        elif len(fields) == 17 and fields[11] == "Simple_repeat":  # rmsk.txt
            unit = fields[10][1:-2]
            chrom = fields[5]
            beg = int(fields[6])
            end = int(fields[7])
        elif len(fields) == 15 and fields[10] == "Simple_repeat":  # RMSK .out
            unit = fields[9][1:-2]
            chrom = fields[4]
            beg = int(fields[5]) - 1
            end = int(fields[6])
        else:
            continue
        if len(set(unit)) == 1:
            continue  # don't try homo-polymers
        if sortedExons is None:
            geneNames = ["."]
        else:
            r = chrom, beg, end
            exonNums = overlappingRanges(r, sortedExons, maxExonLength)
            geneNames = sorted(set(sortedExons[i][3] for i in exonNums))
            if not geneNames:
                continue
        yield chrom, beg, end, unit, geneNames, []

def alignmentsFromMaf(lines):
    alignment = []
    for line in lines:
        if line[0] == "s":
            fields = line.split()
            seqName = fields[1]
            beg = int(fields[2])
            strand = fields[4]
            alignedSeq = fields[6]
            end = beg + len(alignedSeq) - alignedSeq.count("-")
            seqData = seqName, strand, beg, end, alignedSeq
            alignment.append(seqData)
        elif line.isspace():
            if alignment:
                yield alignment
                alignment = []
    if alignment:
        yield alignment

def refSeqName(alignment):
    return alignment[0][0]

def refSeqBeg(alignment):
    return alignment[0][2]

def refSeqEnd(alignment):
    return alignment[0][3]

def qrySeqName(alignment):
    return alignment[1][0]

def qrySeqBeg(alignment):
    return alignment[1][2]

def qrySeqEnd(alignment):
    return alignment[1][3]

def isFwdColinear(oldAln, newAln):
    """Is oldAln upstream of newAln in all sequences?"""
    return all(i[3] <= j[2] for i, j in zip(oldAln, newAln))

def isFwd(colinearAlignments):
    return isFwdColinear(colinearAlignments[0], colinearAlignments[1])

def isColinear(colinearAlignments, newAln):
    oldAln = colinearAlignments[-1]
    if any(i[:2] != j[:2] for i, j in zip(oldAln, newAln)):
        return False
    if len(colinearAlignments) == 1:
        return isFwdColinear(oldAln, newAln) or isFwdColinear(newAln, oldAln)
    if isFwd(colinearAlignments):
        return isFwdColinear(oldAln, newAln)
    else:
        return isFwdColinear(newAln, oldAln)

def canonicalize(colinearAlignments):
    if len(colinearAlignments) > 1 and not isFwd(colinearAlignments):
        colinearAlignments.reverse()

def colinearAlignmentGroups(alignments):
    colinearAlignments = []
    for i in alignments:
        if colinearAlignments and not isColinear(colinearAlignments, i):
            canonicalize(colinearAlignments)
            yield colinearAlignments
            colinearAlignments = []
        colinearAlignments.append(i)
    if colinearAlignments:
        canonicalize(colinearAlignments)
        yield colinearAlignments

def gapsFromColinearAlignments(alignments):
    refSeqPos = refSeqBeg(alignments[0])
    insSize = delSize = 0
    for j, b in enumerate(alignments):
        if j:
            a = alignments[j - 1]
            delSize += refSeqBeg(b) - refSeqEnd(a)
            insSize += qrySeqBeg(b) - qrySeqEnd(a)
        alignmentColumns = itertools.izip(b[0][4], b[1][4])
        # use "read-ahead" technique, aiming to be as fast as possible:
        for x, y in alignmentColumns: break
        while True:
            if x == "-":
                insSize += 1
                for x, y in alignmentColumns:
                    if x != "-": break
                    insSize += 1
                else: break
            elif y == "-":
                delSize += 1
                for x, y in alignmentColumns:
                    if y != "-": break
                    delSize += 1
                else: break
            else:
                if insSize or delSize:
                    yield refSeqPos, refSeqPos + delSize, insSize - delSize
                    refSeqPos += delSize
                    insSize = delSize = 0
                refSeqPos += 1
                for x, y in alignmentColumns:
                    if x == "-" or y == "-": break
                    refSeqPos += 1
                else: break

def numberOfPeriods(gapLength, repeatPeriod):  # crude
    if gapLength < 0:
        return -numberOfPeriods(-gapLength, repeatPeriod)
    return (gapLength + (repeatPeriod - 1) // 2) // repeatPeriod

def appendCopyNumberChange(tandemRepeat, gaps):
    chrom, beg, end, unit, geneNames, copyNumberChanges = tandemRepeat
    period = len(unit)
    diff = 0
    for gapBeg, gapEnd, gapLen in gaps:
        if gapBeg < beg and gapEnd > beg:
            return  # a deletion goes beyond the repeat: give up
        if gapBeg < end and gapEnd > end:
            return  # a deletion goes beyond the repeat: give up
        if gapBeg >= beg and gapEnd <= end:
            diff += numberOfPeriods(gapLen, period)
    copyNumberChanges.append(diff)

def joinedAlnNumsPerRepeat(repNumsPerJoinedAln, repNum):
    for i, x in enumerate(repNumsPerJoinedAln):
        if repNum in x:
            yield i

def doOneRepeat(tandemRepeats, joinedAlns, gaps, repNumsPerJoinedAln, repNum):
    joinedAlnNums = list(joinedAlnNumsPerRepeat(repNumsPerJoinedAln, repNum))
    rep = tandemRepeats[repNum]
    repBeg = rep[1]
    repEnd = rep[2]
    for i in joinedAlnNums:
        x = joinedAlns[i]
        headBeg = refSeqBeg(x[0])
        tailEnd = refSeqEnd(x[-1])
        if headBeg < repBeg and tailEnd > repEnd:
            appendCopyNumberChange(rep, gaps[i])

def repeatNumsPerJoinedAln(tandemRepeats, maxRepeatLength, joinedAlns):
    for joinedAln in joinedAlns:
        headAln = joinedAln[0]
        tailAln = joinedAln[-1]
        r = refSeqName(headAln), refSeqBeg(headAln), refSeqEnd(tailAln)
        yield set(overlappingRanges(r, tandemRepeats, maxRepeatLength))

def gapsPerJoinedAln(joinedAlns, isNeeded):
    for i, j in zip(joinedAlns, isNeeded):
        yield list(gapsFromColinearAlignments(i)) if j else None

def doOneQuerySequence(tandemRepeats, maxRepeatLength, alignments):
    joinedAlns = list(colinearAlignmentGroups(alignments))
    g = repeatNumsPerJoinedAln(tandemRepeats, maxRepeatLength, joinedAlns)
    repNumsPerJoinedAln = list(g)
    gaps = list(gapsPerJoinedAln(joinedAlns, repNumsPerJoinedAln))
    repNums = set(itertools.chain.from_iterable(repNumsPerJoinedAln))
    for i in repNums:
        doOneRepeat(tandemRepeats, joinedAlns, gaps, repNumsPerJoinedAln, i)

def doOneMafFile(tandemRepeats, maxRepeatLength, lines):
    alignments = alignmentsFromMaf(lines)
    for k, v in itertools.groupby(alignments, qrySeqName):
        doOneQuerySequence(tandemRepeats, maxRepeatLength, v)

def tandemGenotypes(opts, args):
    exons = sorted(exonsFromLines(myOpen(opts.genes))) if opts.genes else None
    tandemRepeats = sorted(tandemRepeatsFromLines(myOpen(args[0]), exons))
    maxRepeatLength = maxRangeLength(tandemRepeats)

    if len(args) > 1:
        for fileName in args[1:]:
            doOneMafFile(tandemRepeats, maxRepeatLength, myOpen(fileName))
    else:
        doOneMafFile(tandemRepeats, maxRepeatLength, sys.stdin)

    for chrom, beg, end, unit, geneNames, copyNumberChanges in tandemRepeats:
        if copyNumberChanges and any(i != 0 for i in copyNumberChanges):
            changes = " ".join("%3d" % i for i in sorted(copyNumberChanges))
            out = chrom, str(beg), str(end), unit, ",".join(geneNames), changes
            print "\t".join(out)

if __name__ == "__main__":
    signal.signal(signal.SIGPIPE, signal.SIG_DFL)  # avoid silly error message
    usage = "%prog [options] microsat.txt alignments.maf"
    description = "Try to indicate genotypes of tandem repeats."
    op = optparse.OptionParser(usage=usage, description=description)
    op.add_option("-g", "--genes", metavar="FILE", help=
                  "only check tandem repeats that overlap exons of genes "
                  "in a genePred file")
    opts, args = op.parse_args()
    if not args:
        op.error("please give me repeats and MAF alignments")
    tandemGenotypes(opts, args)
